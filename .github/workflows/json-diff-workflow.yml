name: Process File Changes
on:
  workflow_call:
    inputs:
      file_paths:
        required: true
        type: string

jobs:
  process-changes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history

      - name: Install JD for JSON Diff
        run: |
          sudo wget -nv -O /usr/local/bin/jd https://github.com/josephburnett/jd/releases/download/v1.6.0/jd-amd64-linux
          sudo chmod +x /usr/local/bin/jd
          echo "JD installed successfully."

      - name: Process Files
        run: |
          file_paths=$(echo '${{ inputs.file_paths }}' | jq -r '.[]')
          for file in $file_paths; do
            echo "Processing file: $file"
            
            # Fetch the last commit hash where the file was changed, excluding the very last commit
            last_commit_hash=$(git log -2 --pretty=format:"%H" -- "$file" | tail -n 1)
            echo "Last commit hash for $file: $last_commit_hash"
            
            # Handle case where no previous version is found
            if [ -z "$last_commit_hash" ]; then
              echo "File not found in any previous commits, creating empty json."
              echo "{}" > "${file}_old.json"
            else
              git show ${last_commit_hash}:$file > "${file}_old.json"
            fi
            echo "Content of old JSON:"
            cat "${file}_old.json"
            
            # Fetch the current version of the file
            git show HEAD:$file > "${file}_new.json"
            echo "Content of new JSON:"
            cat "${file}_new.json"
          done

      - name: Use JD to Detect Changes
        run: |
          file_paths=$(echo '${{ inputs.file_paths }}' | jq -r '.[]')
          for file in $file_paths; do
            old_json="${file}_old.json"
            new_json="${file}_new.json"
      
            echo "Verifying contents of ${old_json}:"
            cat "${old_json}"
            echo "Verifying contents of ${new_json}:"
            cat "${new_json}"
      
            # Check if both JSON files exist and are not empty
            if [ -s "${old_json}" ] && [ -s "${new_json}" ]; then
                # Compare OLDJSON and NEWJSON using JD
                jd_command_output=$(jd --set "${old_json}" "${new_json}" 2>&1)
                jd_exit_code=$?
                
                echo "JD Command Output:"
                echo "${jd_command_output}"
                echo "JD Command Exit Code: ${jd_exit_code}"
      
                if [ ${jd_exit_code} -eq 1 ]; then
                    echo "No differences detected in $file."
                elif [ ${jd_exit_code} -eq 0 ]; then
                    echo "Differences Detected in $file:"
                    echo "${jd_command_output}"
                    
                    # Extract only additions (new blocks)
                    additions=$(echo "${jd_command_output}" | grep '^+' | sed -e 's/^+ //' > "${file}_new.json")
                    echo "Additions in $file:"
                    cat "${file}_new.json"
                else
                    echo "JD failed to process files. Review output above for errors."
                fi
            else
                echo "One or both JSON files are empty or missing for ${file}"
            fi
          done
